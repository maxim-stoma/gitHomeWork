<a id="up"></a>


# Инструкция по работе с GIT

1. Краткая история Git
2. Создание репозитория в существующем каталоге
3. Определение состояния файлов
4. Коммит изменений
5. Игнорирование индексации
6. Просмотр истории коммитов
7. Операция отмены
8. Ветвление в Git
9. Создание новой ветки
10. Переключение веток
11. Основы слияние
12. Основные конфликты слияния
13. Управление ветками
14. Основные команды в Git
15. Работа с удаленным репозиторием



## Краткая история Git

Как и многие вещи в жизни, Git начинался с капелькой творческого хаоса и бурных споров.

Ядро Linux — это достаточно большой проект с открытым исходным кодом. 
Большую часть времени разработки ядра Linux (1991–2002 гг.) 
изменения передавались между разработчиками в виде патчей и архивов. 
В 2002 году проект ядра Linux начал использовать проприетарную 
децентрализованную систему контроля версий BitKeeper.

В 2005 году отношения между сообществом разработчиков ядра Linux и 
коммерческой компанией, которая разрабатывала BitKeeper, прекратились, 
и бесплатное использование утилиты стало невозможным. Это сподвигло 
сообщество разработчиков ядра Linux (а в частности Линуса 
Торвальдса — создателя Linux) разработать свою собственную утилиту, 
учитывая уроки, полученные при работе с BitKeeper. Некоторыми целями, 
которые преследовала новая система, были:

* Скорость

* Простая архитектура

* Хорошая поддержка нелинейной разработки (тысячи параллельных веток)

* Полная децентрализация

* Возможность эффективного управления большими проектами, такими как 
ядро Linux (скорость работы и разумное использование дискового пространства)

С момента своего появления в 2005 году, Git развился в простую в 
использовании систему, сохранив при этом свои изначальные качества. 
Он удивительно быстр, эффективен в работе с большими проектами и имеет 
великолепную систему веток для нелинейной разработки.

## Создание репозитория в существующем каталоге

Если у вас уже есть проект в каталоге, который не находится под версионным 
контролем Git, то для начала нужно перейти в него. Если вы не делали этого 
раньше, то для разных операционных систем это выглядит по-разному:

Для Linux: 

>$ cd /home/user/my_project

Для macOS:

>$ cd /Users/user/my_project

Для Windows:

>$ cd C:/Users/user/my_project

А затем выполните команду:

>$ git init

Эта команда создаёт в текущем каталоге новый подкаталог с именем .git, содержащий все необходимые файлы репозитория — структуру Git репозитория. На этом этапе ваш проект ещё не находится под версионным контролем. Подробное описание файлов, содержащихся в только что созданном вами каталоге .git

Если вы хотите добавить под версионный контроль существующие файлы (в отличие от пустого каталога), вам стоит добавить их в индекс и осуществить первый коммит изменений. Добиться этого вы сможете запустив команду git add несколько раз, указав индексируемые файлы, а затем выполнив git commit:

> $ git add *.c

> $ git add LICENSE

> $ git commit -m 'Initial project version'

## Определение состояния файлов

Основной инструмент, используемый для определения, какие файлы в каком состоянии находятся — это команда git status. Если вы выполните эту команду сразу после клонирования, вы увидите что-то вроде этого:

> $ git status

> On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working tree clean

Это означает, что у вас чистый рабочий каталог, другими словами — в нём нет отслеживаемых изменённых файлов. Git также не обнаружил неотслеживаемых файлов, в противном случае они бы были перечислены здесь. Наконец, команда сообщает вам на какой ветке вы находитесь и сообщает вам, что она не расходится с веткой на сервере.

## Основы Git

### Коммит изменений

Теперь, когда ваш индекс находится в таком состоянии, как вам и хотелось, вы можете зафиксировать свои изменения. Запомните, всё, что до сих пор не проиндексировано — любые файлы, созданные или изменённые вами, и для которых вы не выполнили git add после редактирования — не войдут в этот коммит. Они останутся изменёнными файлами на вашем диске. В нашем случае, когда вы в последний раз выполняли git status, вы видели что всё проиндексировано, и вот, вы готовы к коммиту. Простейший способ зафиксировать изменения — это набрать git commit:

> $ git commit

> $ git commit -m "Story 182: fix benchmarks for speed"

### Игнорирование индексации

Несмотря на то, что индекс может быть удивительно полезным для создания коммитов именно такими, как вам и хотелось, он временами несколько сложнее, чем вам нужно в процессе работы. Если у вас есть желание пропустить этап индексирования, Git предоставляет простой способ. Добавление параметра -a в команду git commit заставляет Git автоматически индексировать каждый уже отслеживаемый на момент коммита файл, позволяя вам обойтись без git add:

> $ git commit -am "add new branch"

### Просмотр истории коммитов

После того, как вы создали несколько коммитов или же клонировали репозиторий с уже существующей историей коммитов, вероятно вам понадобится возможность посмотреть что было сделано — историю коммитов. Одним из основных и наиболее мощных инструментов для этого является команда git log.

Если вы запустите команду git log в каталоге клонированного проекта, вы увидите следующий вывод:

>$ git log

> commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon <schacon@gee-mail.com>
Date:   Mon Mar 17 21:52:11 2008 -0700

>>Change version number

> commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon <schacon@gee-mail.com>
Date:   Sat Mar 15 16:40:33 2008 -0700

>>Remove unnecessary test

Так же есть команда:

 > git log --graph -  Отображает ASCII граф с ветвлениями и историей слияний

 ### Операция отмены 

 Будьте осторожны, не все операции отмены в свою очередь можно отменить! Это одна из редких областей Git, где неверными действиями можно необратимо удалить результаты своей работы.

 Отмена может потребоваться, если вы сделали коммит слишком рано, например, забыв добавить какие-то файлы или комментарий к коммиту. Если вы хотите переделать коммит — внесите необходимые изменения, добавьте их в индекс и сделайте коммит ещё раз, указав параметр --amend:

 > $ git commit --amend

 Эта команда использует область подготовки (индекс) для внесения правок в коммит. Если вы ничего не меняли с момента последнего коммита (например, команда запущена сразу после предыдущего коммита), то снимок состояния останется в точности таким же, а всё что вы сможете изменить — это ваше сообщение к коммиту.

 Запустится тот же редактор, только он уже будет содержать сообщение предыдущего коммита. Вы можете редактировать сообщение как обычно, однако, оно заменит сообщение предыдущего коммита.

 Например, если вы сделали коммит и поняли, что забыли проиндексировать изменения в файле, который хотели добавить в коммит, то можно сделать следующее:

 > $ git commit -m 'Initial commit'

 > $ git add forgotten_file

 > $ git commit --amend

## Ветвление в Git

Почти каждая система контроля версий в той или иной форме поддерживает ветвление. Используя ветвление, Вы отклоняетесь от основной линии разработки и продолжаете работу независимо от неё, не вмешиваясь в основную линию. Во многих системах контроля версий создание веток — это очень затратный процесс, часто требующий создания новой копии каталога с исходным кодом, что может занять много времени для большого проекта.

Некоторые люди, говоря о модели ветвления Git, называют её «киллер-фича», что выгодно выделяет Git на фоне остальных систем контроля версий. Что в ней такого особенного? Ветвление Git очень легковесно: операция создания ветки выполняется почти мгновенно, переключение между ветками туда-сюда, обычно, также быстро. В отличие от многих других систем контроля версий, Git поощряет процесс работы, при котором ветвление и слияние выполняется часто, даже по несколько раз в день. Понимание и владение этой функциональностью дает вам уникальный и мощный инструмент, который может полностью изменить привычный процесс разработки.

Ветка в Git — это простой перемещаемый указатель на один из таких коммитов. По умолчанию, имя основной ветки в Git — master. Как только вы начнёте создавать коммиты, ветка master будет всегда указывать на последний коммит. Каждый раз при создании коммита указатель ветки master будет передвигаться на следующий коммит автоматически.

### Создание новой ветки

Что же на самом деле происходит при создании ветки? Всего лишь создаётся новый указатель для дальнейшего перемещения. Допустим вы хотите создать новую ветку с именем testing. Вы можете это сделать командой git branch :

> $ git branch testing

В результате создаётся новый указатель на текущий коммит.

### Переключение веток

Для переключения на существующую ветку выполните команду git checkout. Давайте переключимся на ветку testing:

> $ git checkout testing

В результате указатель HEAD переместится на ветку testing.

Интересная ситуация: указатель на ветку testing переместился вперёд, а master указывает на тот же коммит, где вы были до переключения веток командой git checkout. Давайте переключимся назад на ветку master:

> $ git checkout master

### Примечание

*git log* не показывает все ветки по умолчанию
Если выполнить команду *git log* прямо сейчас, то в её выводе только что созданная ветка «testing» фигурировать не будет.

Ветка никуда не исчезла; просто Git не знает, что именно она вас интересует, и выводит наиболее полезную по его мнению информацию. Другими словами, по умолчанию *git log* отобразит историю коммитов только для текущей ветки.

Для просмотра истории коммитов другой ветки необходимо явно указать её имя: *git log testing* Чтобы посмотреть историю по всем веткам — выполните команду с дополнительным флагом: *git log --all*.
## Основы слияния

Предположим, вы решили, что работа по проблеме #53 закончена и её можно влить в ветку *master*. Для этого нужно выполнить слияние ветки *iss53* точно так же, как вы делали это с веткой *hotfix* ранее. Все, что нужно сделать — переключиться на ветку, в которую вы хотите включить изменения, и выполнить команду *git merge*:

> $ git checkout master
>>Switched to branch 'master'

>$ git merge iss53
>>Merge made by the 'recursive' strategy.
index.html |    1 +
1 file changed, 1 insertion(+)

Результат этой операции отличается от результата слияния ветки *hotfix*. В данном случае процесс разработки ответвился в более ранней точке. Так как коммит, на котором мы находимся, не является прямым родителем ветки, с которой мы выполняем слияние, Git придётся немного потрудиться. В этом случае Git выполняет простое трёхстороннее слияние, используя последние коммиты объединяемых веток и общего для них родительского коммита.

### Основные конфликты слияния

Иногда процесс не проходит гладко. Если вы изменили одну и ту же часть одного и того же файла по-разному в двух объединяемых ветках, Git не сможет их чисто объединить. Если ваше исправление ошибки #53 потребовало изменить ту же часть файла что и *hotfix*, вы получите примерно такое сообщение о конфликте слияния:

> $ git merge iss53
>> Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.

Git не создал коммит слияния автоматически. Он остановил процесс до тех пор, пока вы не разрешите конфликт.

Например:

![git_conflict.jpg](git_conflict.jpg)

### Управление ветками

Теперь, когда вы уже попробовали создавать, объединять и удалять ветки, пора познакомиться с некоторыми инструментами для управления ветками, которые вам пригодятся, когда вы начнёте использовать ветки постоянно.

Команда git branch делает несколько больше, чем просто создаёт и удаляет ветки. При запуске без параметров, вы получите простой список имеющихся у вас веток:

> $ git branch
>> * iss53
>> * *master
>> * testing

Обратите внимание на символ *, стоящий перед веткой *master*: он указывает 
на ветку, на которой вы находитесь в настоящий момент (т. е. ветку, на 
которую указывает HEAD). Это означает, что если вы сейчас сделаете коммит, 
ветка *master* переместится вперёд в соответствии с вашими последними изменениями.

## Основные команды в Git

### Основные команды по работе с GIT

* git init – инициализация локального репозитория 
* git status – получить информацию от git о его текущем состоянии 
* git add – добавить файл или файлы к следующему коммиту 
* git commit -am “message” – добавление файла и создание коммита
* git log – вывод на экран истории всех коммитов с их хеш-кодами 
* git diff – увидеть разницу между текущим файлом и закоммиченным файлом
* 

### Основные команды по работе с ветками в GIT

* git branch - отображение имеющихся веток
* git branch branch_name - создание новой ветки
* git checkout branch_name - переход на другую ветку
* git log --graph - детальное отображения журнала
* git merge - слияние веток 
* git branch -d - удаление ветки из репозитория

## Работа с удаленным репозиторем

Удалённые ссылки — это ссылки (указатели) в ваших удалённых репозиториях, 
включая ветки, теги и так далее. Полный список удалённых ссылок можно 
получить с помощью команды *git ls-remote < remote >* или команды 
*git remote show < remote >* для получения удалённых веток и дополнительной 
информации.

Скажем, у вас в сети есть свой Git-сервер с адресом *git.ourcompany.com.* 
Если вы с него что-то клонируете, команда *clone* автоматически назовёт его 
*origin*, заберёт оттуда все данные, создаст указатель на то, на что там 
указывает ветка *master*, и назовёт его локально origin/master. Git также 
создаст вам локальную ветку master, которая будет начинаться там же, 
где и ветка master в origin, так что вам будет с чего начать.

### Добавление удаленного репозитория.

Чтобы добавить удаленный репозиторий и присвоить ему название, которое используется для удобства как сокращение адреса, просто выполните команду

>git remote add origin https://github.com/ИМЯПОЛЬЗОВАТЕЛЯ/РЕПОЗИТОРИЙ.git

Чтобы отправить изменения (имя ветки) < branch-name > на сервер < remote-name >, задействуйте команду:

> git push < remote-name > < branch-name >

Если ветка, которую вы хотите отправить, не отслеживается, то добавьте флаг —set-upstream. На примере ветки develop это будет выглядеть вот так:

> git push --set-upstream origin develop

Если ветка настроена на отслеживание удаленной ветки, то можно использовать команду:

> git pull

Есть и универсальнее способ: клонирование репозитория. Клонирование копирует все файлы и коммиты удаленного репозитория, после чего уже можно использовать предыдущую команду — *git fetch*, если понадобятся новые изменения из удаленного репозитория.

> git clone [url]

В GitHub есть зеленая кнопка **(Code)**, кликнув на которую можно будет скопировать url-адрес для выбранного способа клонирования или скачать архивом данный репозиторий.

#### Удаление удаленного репозитория

Если интересует убрать подключение к удаленному репозиторию, то используйте команду

> git remote rm < name > 

Где < name > — название репозитория. Вместе с тем удалятся настройки и отслеживаемые ветки.

Чтобы удалить сам удаленный репозиторий, это нужно сделать на сервере, на котором он размещен. На GitHub перейдите в раздел настроек (“Settings”), проскрольте до самого низа, где будет поле Danger Zone. Нажмите на Delete this repository, в открывшемся новом поле введите *Имя пользователя*/*Названия репозитория* для подтверждения удаления. В нашем случае это T.Rex/git-remote-add-origin.

#### Алгоритм действия для работы с удаленным репозиторием:

1. В своём аккаунте на GitHub создать копию репозитория maxim-stoma/gitHomeWork с помощью кнопки "Fork".
2. Клонировать копию репозитория на локальный компьютер.
3. Создать новую ветку.
4. Добавить файл с инструкцией в новую ветку.
5. Дополнить инструкцию разделами по работе с удалёнными репозиториями, pull request.
6. Зафиксировать изменения (коммиты).
7. Отправить изменения на GitHub.
8. На сайте GitHub выполнить Pull request.

## Добавление изображения

![git_logo.png](git_logo.png)

Для работы с изображениями в инструкции по GIT необходимо использовать следующую конструкцию: 

! [название изображения](ссылка на изображение)

[Вверх](#up)