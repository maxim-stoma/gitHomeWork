# Инструкция по работе  с GIT

## Базовые команды (некоторые для примера)

* git init - инициализация, при помощи этой команды мы указываем, что Git начал отслеживать изменения.
* git commit - проще всего описать эту команду как "сохранение", программисты говорят "закоммитить".
* git status - статус это конечно хорошо, но наилучшее описание будет - отображение текущего состояния нашего репозитория, ах да репозиторий - это проще сказать наша папка в которой находится, отслеживаемый файл.


Что такое **Git** и зачем он нужен?
_Git_ - это консольная утилита (помощник), для отслеживания и ведения истории изменения файлов, в вашем проекте. Чаще всего его используют для кода, но можно и для других файлов. Git хорошо отслеживает измения в коде (_тексте_), различного рода изображения принято выделять в отдельный файл.

С помощью **Git** вы можете посмотреть свой проект на более старых версиях, сравнивать, анализировать или отправлять свои изменения в репозиторий.

_Репозиторием_ в **Git** называют хранилище вашего кода и историю его изменений. **Git** работает локально и все ваши репозитории хранятся в определенных папках на жестком диске.


## Подготовка Вашего репозитория, команда git init
Создаем папку с проектом, перетаскиваем ее в редактор кода. Для создания репозитория необходимо в вашей программе редактора кода найти терминал, открыть его, и в нем прописать команду _git init_. В папке с проектом создасться репозиторий, который начнет отслеживаться гитом.


### Добавляем файл для остлеживания изменений, команда git add
В самом начале мы пропустили эту команду, но она одна из самых важных и основных. После инициализации _git init_, нам необходимо добавить файл, который GIT будет отслеживать. Для этого создаем файл с любым произвольным названием, допустим будет git_instructions, и сразу после через точку необходимо указать расширение, в нашем случае это будет .md, отлично, наш файл создан и готов к работе! В терминале записываем *git add имя_файла*, супер теперь гит начнет его отслеживать.

### Проверяем статус (состояние) репозитория, команда git status
Чтобы ничего не упустить, на первых порах необходимо после каждого внесения изменений просматривать состояние нашего репозитория, даже если мы ничего не вносили, случайно нажатый пробел программа будет воспринимать как внесение изменений и напротив нашего файла _git_inctructions.md_ появится странный значок "М", а само название будет выделено желтым. Чтобы узнать вносились ли изменения и на каком этапе мы находимся необходимо прописать команду *git status*.


### Создание коммитов (commit)

Отлично! Мы внесли изменеия в наш проект, например, добавили заголовок или целый абзац, как программа поймет, что данный этап нашей работы необходимо сохранить? 

Для этого необходимо в терминале записать команду *git commit -m "наша заметка"*, -m записывается строго через пробел и означает, что после мы внесем заметку с нашими изменениями, чтобы отслеживать на каждом этапе, что мы изменили и внесли, сохранить изменения можно и при помощи *git add*, но данная комнда не позволяет оставить заметку, которые будут полезны в работе, чтобы не путаться, где и какие изменения были внесены, а так же данная команда не создает коммиты, служить больше для _добавленя_ файла, который будет отслеживаться. 

Так же есть комнда *git commit -a*, -a - это указание программе, сохранить файл, который уже отслеживается. *git commit -am "наша заметка"* - сохранение репозитория, который отслеживается, плюс наша заметка.

### Переключение между версиями репозитория, команда git checkout

Для переключения между версиями необходмо применить команду *git checkout* в данной коменде через пробел мы записываем  начало номера коммита, который хотим просмотреть, например *git checkout 9e658*. 

А где же взять этот номер спросите вы? Вопрос абсолютно уместен, для этого применяем команду *git log*, после программа выдаст нам все сохранения *commit*, они выделены желтым, и через пробел идет номер каждого из них. 

Этот номер необходимо скопировать или запомнить, далее нажимаем **Q**, чтобы выйти из журнала. После записываем первые 5 символов в *git checkout 9e658* и вот магия свершилась. Хорошо, предыдущую версию мы просмотрели, а как вернуться назад? Для этого вводим коменду *git checkout main* или master, если он у вас, у меня main.

### Просмотр различий между версиями репозитория, команда git diff

Для просмотра различий между верисиями репозитория (коммита) необходимо применить команду *git dif*, так же как и у команды *git checkout* в *git dif* необходимо добавить начало номера коммита, которых мы хотим сравнить, поэтому запись будет выглядеть примерно так *git dif 9e658*, номер коммита можно узнать также через команду *git log*, коммит выделен желтым, их номера записаны напротив, через пробел, выйти из журнала _git log_ можно, нажав **Q**.

### Работа с различными _ветками_ в Git, команды _git branch_, _git merge_

Ранее мы переключались между версиями при помощи коммитов, но при реальной работе в команде это несовсем удобно. Для более удобной работы с **Git**, необходимо создавать ветки, в которых будут вносится корректировки, изменения, дополнения. 

С данными ветками обычно работают совершенно разные люди, именно поэтому их и создают для контроля версий. Например, была создана инструкция по использованию **Git**, и нам самим или заказчику что-то не понравилось, захотелось что-то добавить, удалить, изменить. 

Чтобы сохранить наш первоначально рабочий вариант, и вносить изменения, не затрагивая его, создаются дополнительные ветки, в которых эти правки и дополнения и вносятся. Новая ветка создается командой _**git branch** paragraph_work_, paragraph_work - название новой ветки, записывается через пробел после **git branch**. 

Если мы вводим команду **git branch** без названия новой ветки, то _Git_ покажет нам колличество созданных веток на данный момент, ветка на которой мы находимся сейчас, будет выдетена зеленым и перед ней будет звездочка *. 

Для переключения между ветками используем команду **git checkout название_ветки**, название ветки добавлять обязательно и обязательно через пробел, иначе _GIT_ не поймет на какую ветку переключаться и выдаст ошибку. 

После того как все работы в ветке будут закончены, и как вам кажется, добавить тут уже нечего, данную ветку можно **"объединить"** с веткой чистовиком. 

Допустпим наш "чистовик" это ветка _main или master_, для слияния текущей ветки с веткой _main/master_, нам для начала надо переключиться на нее, используя команду **git checkout _main_**, длее удостоверимся, что мы теперь в ветке _main_, для этого введем команду **git branch**, ветка _main_ должна быть теперь зеленого цвета. 

Если все так, отлично, теперь можно объединить ветки, командой **git merge название_ветки**, после слияния ветку, которую мы добавили в _main_ можно удалить. Для этого вводим команду **git branch -d название_ветки**, название ветки опять же указывать обязательно. 

Для просмотра журнала коммитов с отображением веткок, используем команду **git log --graph**. При вводе команды **git branch -d название_ветки**, происходит **"безопасное"** удаление ветки, то есть, если вы ввели эту команду до слияния этой вестки с веткой _main_, не вводили команду **git merge название_ветки**, _Git_ укажет на это, ветка не будет удалена, Вам предложат ее объединить или ввести команду **git branch -D название_ветки**, которая удалит указанную ветку безвозвратно, без сохранения информации, которая в ней была. 

Если при внесении изменений вы создали коммит, то к нему можно будет вернуться и восстановить данные, но если нет, данные удалятся без права на восстановление.

### Работа с изображениями в Git и Markdown

В языке гипер текстовой разметки Markdown изображения добавляются при помощи следующего синтаксиса: **! [] ()**, сначала восклицательный знак, затем без пробела квадратные скобки, далее без пробела круглые скобки. В квадратных скобках указвается название файла или какое-то сообщение, если изображение не подгрузится, чтобы понимать, где это изображение и найти. 

В круглых скобках указывают путь до изображения. Например, если наше изображение находится в папке с проектом, то тогда мы просто указываем название файла с расширением, например, _git_instruction.png_. 

При работе с _Git_ принято изображения и все большие файлы отделять от теста или кода, система _Git_ хорошо отслеживает текст, но не картинки или большие файлы, поэтому необходимо указать системе _Git_ какие файлы надо игнорировать. 

Для этого в папке с проектом создается файл **".gitignore"**, обязательно через точку. И далее в этом файле надо добавить наши изображения или другие большие файлы. Это делается довольно просто мы в **.gitignore** просто записываем имя файла, который _Git_ будет "игнорировать", например, _git_instruction.png_. 

Если у нас много файлов с одинаковым расширением, которые необходимо игнорировать, тогда можно в **.gitignore** записать расширение через звездочку: _*.png_ и тогда все файлы с этим расширением будут игнорироваться и не надо добавлять их каждый раз отдельно в **.gitignore**. 

Далее необходимо **.gitignore** добавить для отслеживания в _Git_. Для этого вводим команду **git add .gitignore**, после сохраняем и создаем коммит **git commit -m "добавил .gitignore"**. Теперь система _Git_ не будет выдавать ошибку при добавлении изображений в папку с проектом.


### Разрешение конфликта _"content conflict"_

При слиянии веток по команде _git merge_, возможен так называемый _"content conflict"_, конфликт контента. Это происходит, если в текущей ветке, в которой мы находимся, и в ветке, которую мы добавляем в текущую, информация находится на одних и тех же строках кода, важно, чтобы информация из новой ветки не содержала информацию из текущей. Например в ветке _main_ у меня находится инструкция по **Git**, для редактирования и добавления новой информации, я создал разные новые ветки. Если все изменения были внесены на основе уже имеющейся ветки _main_, то конфликта не наблюдалось. Если в новых ветках записывать всю информацию "с чистого листа", с первых строк кода и в новой ветке не будет информации из _main_, то будет возникать конфликт. Выглядит это вот так: 
![конфликт](conflict_1.png)

![конфликт2](conflict_2,1.png)

![конфликт2](conflict_2,2.png)



Для разрешения конфликта в VS Code предусмотрены решения:

* Accept Current Change - принять текущие изменения, оставит в ветке _main_ только то, что указано в _Current Change_ (информация которая была в ветке _main_ до слияния). Информация из _Incoming Change_ (информация из ветки, которую добавляем в _main_) - удалится;
* Accept Incoming Change - принять входящие изменения, оставит в ветке _main_ только то, что указано в _Incoming Change_ (информация из ветки, которую добавляем в _main_). Информация из _Current Change_ (информация которая была в ветке _main_ до слияния) - удалится;
* Accept Both Change - принять изменения текущие и входящие, произойдет полное слияние веток, информация из обеих веток сохранится, дальнейшие корректировки проводятся вручную;
* Compare Changes - сравнить изменения.



### Работа с удаленными репозиториями 

Работа с удаленными репозиториями начинается на сайте _GitHub.com_. Это один из самых популярных сервисов по организации работ удаленных репозиториев, грубо говоря - огромный архив кода. Если Вы работаете в команде, то у Вас скорее всего уже должен быть общий репозиторий для работы.

Но на примере изучим внесение изменений в удаленный репозиторий, интересующего нас программиста, работа которого нам очень понравилась и мы хотим предложить ему доработки и учучшения в его работе.

Для этого отправляемся на сайт _GitHub.com_, находим интересующий нас репозиторий. Далее в практике програмистов принято создать копию этого репозитория в наш аккаунт на сайте. 

Для этого необходимо "Форкнуть" его, чтобы безопасно повзаимодействовать с удаленным репозиторием. Находясь на странице с репозиторием необходимо нажать кнпоку **Fork**, она на скин-шоте выделена черным прямоугольником и от этой кнопки высветилось выпадающее меню с поясняющей информацией.
![форк](fork.png)

Нажимаем и далее будет страница, где мы можем изменить имя, и выбрать какие ветки будут скопированны: все (**без галочки**), или же только ветка _main_ (**с галочкой**). Далее жмем зеленую конопку чуть ниже **create fork** и все, репозиторий скопирован. Далее переходим в свой аккаунт на скопированный репозиторий, при копировании эта страница откроется автоматически.

Жмем на зеленую кнопку **Code** и в выпадающем меню копируем ссылку _https:_, нажав кнопку выделенную черным квадратиком с закгругленными углами. 
![клонирование репозитория](copy_link.png)

### Клонирование копии репозитория в свой проект, команда git clone

Далее открываем программу редактора кода, в котором добавлена пустая папка без репозитория, вводим в терминале команду **git clone https://link_repository**.

После необходимо переключится на склонированный репозиторий, для этого в терминале надо ввести **cd name_repository**, здесь необходимо ввести имя, которые мы дали форкнутому репозиторию.  

Далее создаем новую ветку, в которой вносим свои изменения и дополнения, которые хотим предложить. Создаем в новой ветке новый файл с проектом или вставляем текущий, добавляем через _git add_. После чего, конечно же сохраняем, создавая коммиты. 

### Добавление изменений в удаленный репозиторий, команда git push

Чтобы перенести наши коммиты в удаленный репозиторий необходимо воспользоваться командой _git push_. При этом программа выдаст ошибку и предложит ввести немного другую команду, аккуратно без пробелов копируем ее, вводим в терминал и наши изменения отправятся на удаленный репозиторий.

## Команда git pull
Изменения можно вносить и на сайте _GitHub.com_. Создать новую ветку, внести дополнения, изменения. Сделать коммиты. Чтобы перенести все изменения и коммиты с удаленного репозитория на наш локальный, склонированный репозиторий, необходимо воспользоваться командой _git pull_. Данная программа также делает **merge** веток.

Для того чтобы предложить разработчику наши нововведения возвращаемся на _GitHub.com_ и на странице нашего форкнутого репозитория появится кнопка **compare and _pull request_**. Нажав ее, оставляем комментарий, представимся, описываем наши изменения и отправляем, нажав зеленую кнопку ниже. Далее остается лишь ждать ответа, примет ли наши изменения программист или нет.

### Создание собственного удаленного репозитория

* Создаем папку с проектом и добавляем ее в редактор кода

* Инициируем локальный репозиторий (**git init**)

* Создаем в папке спроектом файл README.md

* Добавляем этот файл для отслеживания _git add **README.md**_, 

* сохраняем/коммитим, _git commit -m_

* производим необходимую работу, для реализации нашего проекта, в файле **README.md** принято вносить описание проекта (точки взаимодействия, подключения), делаем коммиты параллельно, завершаем проект

* На сайте _GitHub.com_ создаем новый репозиторий, даем ему имя, выбираем какой он будет: публичный (public) или для ограниченного круга лиц (private)

* Далее связываем локальный репозиторий с удаленным репозиторием, для этого _GitHub.com_ нам поможет, после создания удаленного репозитория _GitHub.com_ предложит несколько вариантов. Нам необходим 3-ий, который начинается с _...or push_. Нам необходимо, нажав кнопку справа, скопировать предложенный код и вставить его в терминал. 
1. _git branch -M main_ - переименовать главную ветку, если надо
2. _git remote add origin **https://ссылка_на_репозиторий**_ - связываем (добавляем) удаленный репозиторий к локальному
3. _git push -u origin main_ - добавляем все изменения в локальный репозиторий.




### Вот краткая инструкция для начала работы.
На первых порах ее должно хватить. Необходимо не забывать про пробелы, когда записываем команды, например, *git commit -a*, *git checkout 9e658*. По примеру и подобию записываются и другие, так же при проверке версий будьте внимательны, номер коммита _main_ в *git dif* вбивать бесполезно, программа переключается между версией _main_ и предыдущими, так же программа сравнивает _main_ с предыдущими, но не наоборот, ввод номер коммита _main_ выдаст ошибку! Надеюсь данная инструкция была полезна и понятна.

