
# Инструкция для работы с Git и удаленными репозиториями 
  ## Что такое Git?

> Git — это специальная программа, которая позволяет отслеживать любые изменения в файлах, хранить их версии и оперативно возвращаться в любое сохранённое состояние.
Большинство других систем контроля версий хранят информацию в виде списка изменений в файлах. Git работает иначе — он хранит скорее набор снимков — полное отображение того, как выглядит файл в момент сохранения. Это позволяет всегда иметь полную информацию обо всех файлах и быстро восстанавливать любую из предыдущих версий.

## Основные команды 
* **Git init**

*Команда `git init` создает новый репозиторий Git. С ее помощью можно преобразовать существующий проект без управления версиями в репозиторий Git или инициализировать новый пустой репозиторий. Большинство остальных команд Git невозможно использовать без инициализации репозитория, поэтому данная команда обычно выполняется первой в рамках нового проекта.*

* **Git status** 

*Команда `git status` отображает состояние рабочего каталога и раздела проиндексированных файлов. С ее помощью можно проверить индексацию изменений и увидеть файлы, которые не отслеживаются Git. Информация об истории коммитов проекта не отображается при выводе данных о состоянии. Для этого используется команда `git log` .*

* **Git log** 

*Команда `git log` используется для просмотра истории коммитов, начиная с самого свежего и уходя к истокам проекта. По умолчанию, она показывает лишь историю текущей ветки, но может быть настроена на вывод истории других, даже нескольких сразу, веток.*

* **Git add** 

Команда `git add` — это первая команда в цепочке операций, предписывающей Git «сохранить» снимок текущего состояния проекта в истории коммитов. Когда `git add` используется как отдельная команда, она переносит ожидающие изменения из рабочего каталога в раздел проиндексированных файлов.

* **Git commit** 

По-английски commit значит «фиксировать». Git-коммит — это операция, которая берет все подготовленные изменения и отправляет их в репозиторий как единое целое.
             
* **Git branch** 

Команда `git branch` позволяет создавать, просматривать, переименовывать и удалять ветки. Она не дает возможности переключаться между ветками или выполнять слияние разветвленной истории. Именно поэтому команда `git branch` тесно связана с командами `git checkout` и `git merge`

* **git checkou** 

Команда `git checkout` позволяет перемещаться между ветками, созданными командой `git branch` . При переключении ветки происходит обновление файлов в рабочем каталоге в соответствии с версией, хранящейся в этой ветке, а Git начинает записывать все новые коммиты в этой ветке.

* **git merge**

Команда `git merge` объединяет несколько последовательностей коммитов в общую историю. Чаще всего команду `git merge` используют для объединения двух веток.


* **git checkout branch_name**
 — перейти в другую ветку; 

* **git branch -b [branch name]** — создать новую ветку и переместиться в неё;
 * **git branch -d [branch name]** — удалить ветку по имени;
## Что такое Markdown ?
 >**Markdown** — это простой язык разметки, используемый для создания форматированного текста (например, HTML) с помощью текстового редактора. 

 ### Разметка  Markdown:

*Курсив*- для того чтобы создать  шрифт курсив необходимо добавить АСТЕРИКС по обе стороны от слова .



**Жирный**- для создания жирного шрифта необходимо добавить два символа  АСТЕРИКС по обе стороны от слова .

~~Зачеркнутый~~ - зачеркнутый шрифт создается  с помощью двойным символом  " ~ " по обе стороны от нужного текста.

**Заголовок**- создается с помощью знака решетки . Добавление одной решетки создает заголовок первого уровня , добавление двух знаков решетки создает заголовок второго уровня и т.д 

**Неупорядоченный список**- создается при помощью астерикса. В начале каждого нового  ряда списка ставится значок " * ".
* первый 
* второй 
* третий 
---
**Упорядоченный список**- создается при помощью цифр . В начале каждого нового ряда в списке вставляется цивра или буква за которой вставляется точка .
 1. первый 
 2. второй
 3. третий

 **Цитаты** 

Цитаты  оформляются как в емейлах,
с помощью символа >.

## **Работа с изображениями в Git**

для работы с изображениями необходимо добавить  файл .gitignore , а в файле с языком разметки Markdoun вписать следующую конструкцию :  Факториал ,квадратные скобки и круглые .
 ![images.ing](images.png) 

## Работа с изображениями

**Размер изображения**

Отличительную формулировку Меньше версии 2.2.0 стали встроенными функциями для работы с изображениями, которые позволяют предоставить следующие данные:

Размер (ширина и высота) — image-size(url).

Ширину — image-width(url).

Высоту — image-height(url).

## Что такое ссылка на Git ?

**Ссылка**  — это косвенный указатель на коммит в Git, своего рода удобный псевдоним для хеша коммита. Это внутренний механизм представления веток и тегов в Git.

### Как добавить ссылку в git?

 Вы можете создать встроенную ссылку, заключив текст ссылки в квадратные скобки [ ], а затем заключив URL-адрес в скобки ( ) . Вы также можете использовать сочетание клавиш Command + K, чтобы создать ссылку. Когда у вас выделен текст, вы можете вставить URL-адрес из буфера обмена, чтобы автоматически создать ссылку из выделения.

 ### Что делает ссылка?

Ссы́лка — запись, которая идентифицирует документ или его часть. Используется в документе для связи с другим документом, а также для связи одной части документа с другой частью. Полная идентификация документа используется в библиотечном деле в виде библиографической записи.

## **Библиография** 
[Git: коммиты, ветки и перемещение между ними](https://1cloud.ru/)

 [Разметка  Markdown ](https://help.vivaldi.com/ru/services-ru/forum-ru/markdown-formatting)

[  Помощник по оформлению Markdown файлов](https://gist.github.com/Jekins/2bf2d0638163f1294637)

# Работа с удалёнными репозиториями

Удалённые репозитории представляют собой версии вашего проекта, сохранённые в интернете или ещё где-то в сети. У вас может быть несколько удалённых репозиториев, каждый из которых может быть доступен для чтения или для чтения-записи. Взаимодействие с другими пользователями предполагает управление удалёнными репозиториями, а также отправку и получение данных из них. Управление репозиториями включает в себя как умение добавлять новые, так и умение удалять устаревшие репозитории, а также умение управлять различными удалёнными ветками, объявлять их отслеживаемыми или нет и так далее. В данном разделе мы рассмотрим некоторые из этих навыков.

## Просмотр удалённых репозиториев
> Для того, чтобы просмотреть список настроенных удалённых репозиториев, вы можете запустить команду git remote. Она выведет названия доступных удалённых репозиториев. Если вы клонировали репозиторий, то увидите как минимум origin — имя по умолчанию, которое Git даёт серверу, с которого производилось клонирование

## Получение изменений из удалённого репозитория — Fetch и Pull

>Данная команда связывается с указанным удалённым проектом и забирает все те данные проекта, которых у вас ещё нет. После того как вы выполнили команду, у вас должны появиться ссылки на все ветки из этого удалённого проекта, которые вы можете просмотреть или слить в любой момент.

>Когда вы клонируете репозиторий, команда clone автоматически добавляет этот удалённый репозиторий под именем «origin». Таким образом, git fetch origin извлекает все наработки, отправленные на этот сервер после того, как вы его клонировали (или получили изменения с помощью fetch). Важно отметить, что команда git fetch забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент. Вам необходимо вручную слить эти данные с вашими, когда вы будете готовы.

>Если ветка настроена на отслеживание удалённой ветки (см. следующий раздел и главу Ветвление в Git чтобы получить больше информации), то вы можете использовать команду git pull чтобы автоматически получить изменения из удалённой ветки и слить их со своей текущей. Этот способ может для вас оказаться более простым или более удобным. К тому же, по умолчанию команда git clone автоматически настраивает вашу локальную ветку master на отслеживание удалённой ветки master на сервере, с которого вы клонировали репозиторий. Название веток может быть другим и зависит от ветки по умолчанию на сервере. Выполнение git pull, как правило, извлекает (fetch) данные с сервера, с которого вы изначально клонировали, и автоматически пытается слить (merge) их с кодом, над которым вы в данный момент работаете.
# Что такое пул-реквест?
>**Пул-реквест** это *запрос* (англ. request — «запрос») на интеграцию изменений из одной ветки в другую. Причем в ветке может быть всего один коммит одного разработчика, а может быть несколько коммитов разных авторов. В большинстве случаев пул-реквест используется для интеграции нового функционала или для исправления бага в основной ветке проекта.

>Пул-реквест также содержит короткое описание изменений и причин, по которым эти изменения вносятся. Обычно между автором пул-реквеста и ревьюерами происходит обсуждение этих изменений.

>**Ревьюеры** — это другие разработчики, работающие над этим проектом и способные дать обратную связь по вносимым изменениям. В проектах с открытым исходным кодом в роли ревьюеров обычно выступают ключевые контрибьюторы или мейнтейнеры. В других случаях (например, в вашей команде на работе) ревьюерами бывают более опытные коллеги (разработчики-сеньоры).

## Коммуникация
>По сути пул-реквесты облегчают процесс совместной работы с другими людьми. Они позволяют сделать прозрачной коммуникацию между авторами и ревьюерами путем показа дифф-ов (diffs), коммитов (commits) и комментариев, поясняющих изменения.

>До пул-реквестов изменения подтверждались по электронной почте или в IRC-каналах. Там писали название ветки или указывали набор коммитов. Чтобы смержить (слить) изменения, мейнтейнер или выпускающий разработчик должен был сравнить изменения с текущей версией кода на собственном компьютере, дать фидбэк, а потом подождать ответа с дополнительными изменениями. Согласованные изменения мержил на своей локальной машине, а затем отправлял их в общую кодовую базу. Пул-реквесты существенно упрощают весь этот процесс.

>Особенно это касается крупных проектов, над которыми работают тысячи контрибьюторов. Поэтому многие из подобных проектов придерживаются именно процедуры пул-реквестов. Часто они также применяют рабочий процесс под названием «GitHub flow». GitHub flow предполагает форки целых проектов и создание пул-реквестов в этих форках.

>Поначалу все это кажется страшным и непонятным, но не волнуйтесь! Просто помните, что основная идея остается прежней: вы запрашиваете разрешение на перенос изменений из одной ветки в другую.

>Еще одно преимущество процедуры пул-реквестов в том, что всем сотрудникам видна вся коммуникация по изменениям. К вашим услугам поиск по внесенным изменениям и возможность использовать теги. В общем, отслеживать происходящее относительно легко. Контекст и предыдущие решения не теряются где-то в потоках электронных писем или окнах чатов. Любой разработчик, участвующий в проекте, может легко найти и просмотреть нужные сведения.

## Автоматизация

>Поскольку пул-реквесты приобрели огромную популярность в сообществе разработчиков, GitHub и другие подобные платформы создали обширный набор вебхуков (webhooks), спроектированных на основе GitHub flow. Эти вебхуки делают возможной автоматизацию работы. В наши дни распространена практика, когда задачи непрерывной интеграции выполняются при каждом коммите, и поэтому являются частью пул-реквеста. По своему опыту могу судить, что это одно из самых подходящих мест для автоматизации. Речь идет не только о запуске автоматизированных тестов. Из изменений в пул-реквесте можно разворачивать целые окружения, чтобы проверить, гладко ли все прошло.

>Раньше подобные инструменты интеграции были дорогими. Команде или приходилось поддерживать инфраструктуру для задач автоматизации, либо платить за сервисы. В последнее время все больше инструментов становятся доступными, а значит, настройка автоматизированных задач облегчается. Например, вы можете воспользоваться бесплатными предложениями таких компаний как Netlify и Travis.

>GitHub пошел даже еще дальше и выпустил GitHub Actions. Actions позволяют вам создавать рабочие процессы автоматизации из набора отдельных маленьких задач, пригодных для компоновки. Непременно попробуйте!
Просмотр удалённых репозиториев
Для того, чтобы просмотреть список настроенных удалённых репозиториев, вы можете запустить команду git remote. Она выведет названия доступных удалённых репозиториев. Если вы клонировали репозиторий, то увидите как минимум origin — имя по умолчанию, которое Git даёт серверу, с которого производилось клонирование
 ## Проверки статуса
>Последнее большое преимущество пул-реквестов это концепция проверок статуса (status checks). Проверки статуса это просто набор задач, выполняемых для каждого коммита в пул-реквесте, и выдающих результат «успех» (success) или «провал» (failure). Это буквально чек-листы для проверки того, готовы ли изменения к отправке в кодовую базу.

>Проверять можно что угодно. В большинстве команд проверки статуса состоят из автоматизированных тестов, за которыми следует проверка стиля, после которой проверяется, получил ли этот код одно или два одобрения на ревью. Изменения не могут быть слиты, пока не пройдут все эти проверки.

>Стоит также остановиться на теме код-ревью. Поскольку пул-реквесты сильно улучшают возможности коммуникации и сотрудничества, естественно, что многие команды применят их в код-ревью. Таким образом прямо со страницы пул-реквеста можно осуществлять менеджмент ревьюеров, ревью и статуса запросов (одобрено или нет). Во многих крупных проектах есть даже автоматическая процедура добавления отдельных пользователей или групп к пул-реквесту — в зависимости от файлов, которые были изменены. Если хотите пример, посмотрите документацию CODEOWNERS.

![Group2.ipg](Group2.png)

